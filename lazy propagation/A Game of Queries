Problem Description

You are given an array A of numbers, which is circular and an array B of size M X 3, having operations as follows.

If B[i][0] is not equal to 2, increase all numbers in the segment [ B[i][1], B[i][2] ] by B[i][0] .

If B[i][0] = 2, calculate the minimum of the array in given range inclusive of both B[i][1] and B[i][2] .

Return an array of answers to the Type 2 queries.

Assuming circular segments, if we consider 5 elements and the segment [3, 1], we refer to index sequence [3, 4, 1].



Problem Constraints

1 <= |A| <= 100000

1 <= |B| <= 100000

1 <= A[i] <= 500

It is assured that after any operation, all the numbers will fit into 32 bit integers.



Input Format

First argument is vector A.

Second argument is the vector of vectors B.



Output Format

Return an array, consisting of answers to the type 2 queries.



Example Input

Input 1:

 A = [2, 3, 4]
B = [    [1, 1, 2]
         [2, 3, 1]
    ]
Input 2:

A = [1, 2, 3]
B = [    [1, 3, 3]
         [2, 1, 3]
         [2, 1, 1]
    ]


Example Output

Output 1:

 [3]
Output 2:

 [1, 1]


Example Explanation

Explanation 1:

 After first operation, array is [3, 4, 4]. Now minimum across next range is 3.
Explanation 2:

 After first operation, array is [1, 2, 4]. Minimums can now be calculated.
 
 public class Solution {
    int[] seg;
    int[] lazy;
    public int[] solve(int[] A, int[][] B) {
        int len = A.length;
        seg = new int[4*len];
        lazy = new int[4*len];

        build(A, 0, 0, len-1);
        ArrayList<Integer> ans = new ArrayList<Integer>();

        for(int i=0;i<B.length;i++)
        {
            if(B[i][0] == 2)
            {
                if(B[i][1]<=B[i][2])
                {
                    ans.add(getmin(0, 0, len-1, B[i][1]-1, B[i][2]-1));
                }
                else
                {
                    int m1 = getmin(0, 0, len-1, B[i][1]-1, len-1);
                    int m2 = getmin(0, 0, len-1, 0, B[i][2]-1);

                    ans.add(Math.min(m1, m2));
                }
            }
            else
            {
                if(B[i][1]<=B[i][2])
                {
                    increase(0, 0, len-1, B[i][1]-1, B[i][2]-1, B[i][0]);
                }
                else
                {
                    increase(0, 0, len-1, B[i][1]-1, len-1, B[i][0]);
                    
                    increase(0, 0, len-1, 0, B[i][2]-1, B[i][0]);
                   
                }
                
            }
        }

        int[] fans = new int[ans.size()];

        for(int i=0;i<ans.size();i++)
        {
            fans[i] = ans.get(i);
        }

        return fans;
    }

    public void build(int[] A, int ind, int l, int r)
    {
        if(l == r)
        {
            //System.out.println(A[l]);
            seg[ind] = A[l];
            return;
        }

        int m = (l+r)/2;
        build(A, 2*ind+1, l, m);
        build(A, 2*ind+2, m+1, r);

        seg[ind] = Math.min(seg[2*ind+1], seg[2*ind+2]);
        //System.out.println(ind + "-" + l + "-" + r + "-" + seg[ind] + "build");
    }

    public void increase(int ind, int l, int r, int pl, int pr, int up)
    {
        if(lazy[ind] > 0)
        {
            seg[ind] += lazy[ind];
            //System.out.println(seg[ind] + "inclazy");
            if(l != r)
            {
                lazy[2*ind+1] += lazy[ind];
                lazy[2*ind+2] += lazy[ind];
            }
            lazy[ind] = 0;
        }

        if(pr<l || r<pl)
        {
            return;
        }
        if(pl<=l && pr>=r)// overlap
        {
             //System.out.println(l+"-"+r+"-"+seg[ind] + "before inc over");
            seg[ind] += up;
 //System.out.println(l+"-"+r+"-"+seg[ind] + "after inc over");
            if(l != r)
            {
                lazy[2*ind+1] += up;
                lazy[2*ind+2] += up;
            }
            return;
        }
        
        int m = (l+r)/2;
        increase(2*ind+1, l, m, pl, pr, up);
        increase(2*ind+2, m+1, r, pl, pr, up);

        seg[ind] = Math.min(seg[2*ind+1], seg[2*ind+2]);

         //System.out.println(ind + "-" + l + "-" + r + "-" + seg[ind]+ "-"+ up + "increase");
    }

    int getmin(int ind, int l, int r, int pl, int pr)
    {
        //System.out.println(ind +"-"+l+"-"+r+"-"+pl+"-"+pr);
        if(lazy[ind] > 0)
        {
            seg[ind] += lazy[ind];

            if(l!=r)
            {
                lazy[2*ind+1] += lazy[ind];
                lazy[2*ind+2] += lazy[ind];
            }
            lazy[ind] = 0;
        }

        if(pr<l || r<pl) // no overlap
        {
            return Integer.MAX_VALUE;
        }
        if(pl<=l && r<=pr)// overlap
        {
            //System.out.println(l+"-"+r+"-"+pl+"-"+pr+ "--"+ind+"-"+seg[ind]+"getmin1");
            return seg[ind];
        }

        int m = (l+r)/2;
        int a = getmin(2*ind+1, l, m, pl, pr);
        int b = getmin(2*ind+2, m+1, r, pl, pr);

        int c = Math.min(a, b);
        //System.out.println(l+"-"+r+"-"+pl+"-"+pr+ "--"+c+"getmin2");
        return c;
    }
}
